## 基础概念

### CPU核心数和线程数的关系

核心数:线程数=1:1  ;使用了超线程技术后---> 1:2

### CPU时间片轮转机制

又称RR调度，会导致上下文切换

### 什么是进程和线程

* 进程：程序运行资源分配的最小单位，进程内部有多个线程，会共享这个进程的资源
* 线程：CPU调度的最小单位，必须依赖进程而存在

### 并行和并发

* 并行：同一时刻，可以同时处理事情的能力   
    举例：食堂有八个窗口，八个窗口可以同时打饭   
* 并发：与单位时间相关，在单位时间内可以处理事情的能力  
    举例：某个时间段内可以打多少分饭     

### 高并发编程的意义、好处和注意事项

* 好处：充分利用cpu的资源、加快用户响应的时间，程序模块化，异步化。
* 缺点：  
    线程共享资源，存在冲突；  
    容易导致死锁；  
    用太多的线程，就有搞垮机器的可能；  

## 认识Java里的线程

### 新建线程的方式：三种

* 继承类Thread
* 实现接口Runnable
* 实现接口Callable 

### 怎么样才能然java里的线程安全停止工作呢？

1. 自然执行完；2. 抛出异常；

* 过时不建议使用的方法
    1. stop() -> 过于强势，强行终止线程，无法保证线程资源正常释放；
    2. resume() ->  线程不会释放资源；
    3. suspend() -> 挂起，线程不会释放资源，容易导致死锁
* 推荐使用方法
    1. interrupt() -> 中断一个线程，并不是强行关闭这个线程，只是跟这个线程打个招呼，将线程的中断标志位置为true，线程是否中断，由线程本身决定
    2. isInterrupted() -> 判定当前线程是否处于中断状态
    3. static方法interrupted() -> 判定当前线程是否处于中断状态，同时中断标志位改为false。    

> 注意：java线程是协作式的

> 方法里如果抛出InterruptedException，线程的中断标志位会被复位成false，如果确实是需要中断线程，要求我们自己在catch语句块里再次调用interrupt()

## java线程深入了解

### 线程常用方法和线程的状态

#### 线程只有5种状态。整个生命周期就是这几种状态的切换

* run()和start() ：run方法就是普通对象的普通方法，由谁调用就归属哪个线程。只有调用了start()后，Java才会将线程对象和操作系统中实际的线程进行映射，再来执行run方法。
* yield() ：让出cpu的执行权，将线程从运行转到可运行状态，但是下个时间片，该线程依然有可能被再次选中运行。

#### 线程的优先级
取值为1~10，缺省为5，但线程的优先级不可靠，不建议作为线程开发时候的手段

#### 守护线程
和主线程共死，finally不能保证一定执行

![image.png](https://upload-images.jianshu.io/upload_images/4617498-55d85f7538556de1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)


## 线程间的共享

### synchronized内置锁（同步锁）
线程安全，既能确保可见性，又能确保原子性
* 对象锁，锁的是类的对象实例。
* 类锁 ，锁的是每个类的的Class对象，每个类的的Class对象在一个虚拟机中只有一个，所以类锁也只有一个。如：static修饰的方法始类锁。

### volatitle关键字，最轻量的同步机制
适合于只有一个线程写，多个线程读的场景，因为它只能确保可见性，不能确保原子性。

### ThreadLocal的使用
线程变量。每个线程拥有自己的变量，可以理解为是个map，类型 Map<Thread,Integer>

## 线程间协做

> 轮询：难以保证及时性，资源开销很大

## 等待和通知

* wait() 对象上的方法
* notify()、notifyAll() 对象上的方法

### 等待和通知的标准范式

* 等待方：  
    1. 获取对象的锁  
    2. 循环里判断条件是否满足，不满足调用wait()方法  
    3. 条件满足执行业务逻辑

* 通知方
    1. 获取对象的锁
    2. 改变条件
    3. 通知所有等待在对象的线程

> notify和notifyAll应该用谁？  
应该尽量使用notifyAll，使用notify因为有可能发生信号丢失的的情况

#### 等待超时模式实现一个连接池

```
假设  等待时间时长为T，当前时间now+T以后超时

long  overtime = now+T;
long remain = T;//等待的持续时间
while(result不满足条件&& remain>0){
	wait(remain);
	remain = overtime – now;//等待剩下的持续时间
}
return result;
```

### join()方法

面试点：
线程A，执行了线程B的join方法，线程A必须要等待线程B执行完成后，线程A才能继续自己的工作。

### 调用yield() 、sleep()、wait()、notify()等方法对锁有何影响？

面试点
* 线程在执行yield()以后，持有的锁是不释放的
* sleep()方法被调用以后，持有的锁是不释放的
* 调用方法之前，必须要持有锁。调用了wait()方法以后，锁就会被释放，当wait方法返回的时候，线程会重新持有锁
* 调用方法之前，必须要持有锁，调用notify()方法本身不会释放锁的，自由该锁持有的方法执行完后才会释放锁，所有往往将notify()方法放到同步方法最后执行





  