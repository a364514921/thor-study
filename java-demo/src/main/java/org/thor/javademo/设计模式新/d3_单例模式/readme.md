### 第 3 章 单例模式【Singleton Pattern】

这个模式是很有意思，而且比较简单，但是我还是要说因为它使用的是如此的广泛，如此的有人缘， 单例就是单一、独苗的意思，那什么是独一份呢?你的思维是独一份，除此之外还有什么不能山寨的呢? 我们举个比较难复制的对象:皇帝
中国的历史上很少出现两个皇帝并存的时期，是有，但不多，那我们就认为皇帝是个单例模式，在这 个场景中，有皇帝，有大臣，大臣是  要上朝参见皇帝的，今 参拜的皇帝应该和昨 、前 的一样(过 渡期的不考虑， 找茬哦)，大臣磕完头，抬头一看，嗨，还是昨 那个皇帝，单例模式，绝对的单例模式，

看到没，大臣  见到的都是同一个皇帝，不会产生错乱情况，反正都是一个皇帝，是好是坏就这一 个，只要提到皇帝，大家都知道指的是谁，清晰，而又明确。问题是这是通常情况，还有个例的，如同一 个时期同一个朝代有两个皇帝，怎么办?
单例模式很简单，就是在构造函数中多了加一个构造函数，访问权限是 private 的就可以了，这个模 式是简单，但是简单中透着风险，风险?什么风险?在一个 B/S 项目中，每个 HTTP Request 请求到 J2EE 的容器上后都创建了一个线程,每个线程都要创建同一个单例对象,怎么办?,好,我们写一个通用的单例程 序,然后分析一下:

我们来看黄色的那一部分，假如现在有两个线程 A 和线程 B，线程 A 执行到 this.singletonPattern = new SingletonPattern()，正在申请内存分配，可能需要 0.001 微秒，就在这 0.001 微秒之内，线程 B 执 行到 if(this.singletonPattern == null)，你说这个时候这个判断条件是 true 还是 false?是 true，那 然后呢?线程 B 也往下走，于是乎就在内存中就有两个 SingletonPattern 的实例了，看看是不是出问题了?
  if(this.singletonPattern == null){ //如果还没有实例，则创建一个
 this.singletonPattern = new SingletonPattern();
 }
第 14 页
您的设计模式
 如果你这个单例是去拿一个序列号或者创建一个信号资源的时候，会怎么样?业务逻辑混乱!数据一致性 校验失败!最重要的是你从代码上还看不出什么问题，这才是最要命的!因为这种情况基本上你是重现不 了的，不寒而栗吧，那怎么修改?有很多种方案，我就说一种，能简单的、彻底解决问题的方案: